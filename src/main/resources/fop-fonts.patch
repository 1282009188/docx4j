Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/autodetect/FontInfoFinder.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/autodetect/FontInfoFinder.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/autodetect/FontInfoFinder.java	(working copy)
@@ -62,11 +62,47 @@
             log.trace("Font: " + customFont.getFullName() 
                     + ", family: " + customFont.getFamilyNames() 
                     + ", PS: " + customFont.getFontName() 
-                    + ", EmbedName: " + customFont.getEmbedFontName());
+                    + ", EmbedName: " + customFont.getEmbedFontName()
+                    + ", subFamily: " + customFont.getFontSubName()                    
+            );
         }
 
+//System.out.println("Font: " + customFont.getFullName() 
+//                + ", family: " + customFont.getFamilyNames() 
+//                + ", PS: " + customFont.getFontName() 
+//                //+ ", EmbedName: " + customFont.getEmbedFontName() //Same as getFontName
+//                //+ ", subFamily: " + customFont.getFontSubName()  // Seems to be null always                  
+//        );
+        
+        /* Examples:
+         * 
+         * Font: URW Bookman L Demi Bold Italic, family: [URW Bookman L], PS: URWBookmanL-DemiBoldItal, EmbedName: URWBookmanL-DemiBoldItal, subFamily: null
+
+Font: Century Schoolbook L Bold, family: [Century Schoolbook L], PS: CenturySchL-Bold, EmbedName: CenturySchL-Bold, subFamily: null
+
+			Examples of family names (note the square brackets):
+			
+				Font: , family: [DejaVu Sans]
+				Font: , family: [OpenSymbol]
+				Font: , family: [Cambria]
+				Font: , family: [Calibri]
+				Font: , family: [Times New Roman]
+				Font: , family: [FreeMono]
+			
+			Multiple values are comma separated.
+			
+				Font: , family: [DejaVu Sans Condensed, DejaVu Sans]
+				Font: , family: [Hor, ae_Hor]
+				Font: , family: [padmaa-Bold.1.1, padmaa, padmmaa]
+
+         * 
+         */
+                
         // default style and weight triplet vales (fallback)
         String strippedName = stripQuotes(customFont.getStrippedFontName());
+        	// This is almost always the PS name
+        
+        
         //String subName = customFont.getFontSubName();
         String fullName = stripQuotes(customFont.getFullName());
         String searchName = fullName.toLowerCase();
@@ -81,9 +117,10 @@
         //Full Name usually includes style/weight info so don't use these traits
         //If we still want to use these traits, we have to make FontInfo.fontLookup() smarter
         triplets.add(new FontTriplet(fullName, Font.STYLE_NORMAL, Font.WEIGHT_NORMAL, 0));
-        if (!fullName.equals(strippedName)) {
-            triplets.add(new FontTriplet(strippedName, Font.STYLE_NORMAL, Font.WEIGHT_NORMAL, 0));
-        }
+//        System.out.println( fullName + " -- full name");
+//        if (!fullName.equals(strippedName)) {
+//            triplets.add(new FontTriplet(strippedName, Font.STYLE_NORMAL, Font.WEIGHT_NORMAL, 0));
+//        }
         Set familyNames = customFont.getFamilyNames();
         Iterator iter = familyNames.iterator();
         while (iter.hasNext()) {
@@ -133,6 +170,9 @@
         embedUrl = fontUrl.toExternalForm();
         EmbedFontInfo fontInfo = new EmbedFontInfo(null, customFont.isKerningEnabled(),
                 fontTripletList, embedUrl);
+        fontInfo.setPanose(customFont.getPanose());
+        fontInfo.setEmbeddable(customFont.isEmbeddable());
+        fontInfo.setPostScriptName(customFont.getFontName());
         if (fontCache != null) {
             fontCache.addFont(fontInfo);
         }
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/CustomFont.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/CustomFont.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/CustomFont.java	(working copy)
@@ -57,6 +57,26 @@
     private Map kerning;
 
     private boolean useKerning = true;
+    
+    private boolean isEmbeddable = true; 
+	public boolean isEmbeddable() {
+		return isEmbeddable;
+	}
+	public void setEmbeddable(boolean isEmbeddable) {
+		this.isEmbeddable = isEmbeddable;
+	}
+    
+    
+    private Panose panose = null;
+
+    public Panose getPanose() {
+		return panose;
+	}
+
+	public void setPanose(Panose panose) {
+		this.panose = panose;
+	}
+    
 
     /** {@inheritDoc} */
     public String getFontName() {
@@ -448,4 +468,5 @@
         }
     }
 
+
 }
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/EmbedFontInfo.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/EmbedFontInfo.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/EmbedFontInfo.java	(working copy)
@@ -38,6 +38,32 @@
     protected boolean kerning;
     /** the list of associated font triplets */
     protected List fontTriplets;
+    
+    private boolean isEmbeddable = true; 
+	public boolean isEmbeddable() {
+		return isEmbeddable;
+	}
+	public void setEmbeddable(boolean isEmbeddable) {
+		this.isEmbeddable = isEmbeddable;
+	}    
+    
+    protected Panose panose = null;
+
+    public Panose getPanose() {
+		return panose;
+	}
+
+	public void setPanose(Panose panose) {
+		this.panose = panose;
+	}
+    
+	protected String postScriptName = null;
+	public String getPostScriptName() {
+		return postScriptName;
+	}
+	public void setPostScriptName(String postScriptName) {
+		this.postScriptName = postScriptName;
+	}
       
     /**
      * Main constructor
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/MultiByteFont.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/MultiByteFont.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/MultiByteFont.java	(working copy)
@@ -40,8 +40,9 @@
     private String namePrefix = null;    // Quasi unique prefix
 
     private BFEntry[] bfentries = null;
+    
 
-    /**
+	/**
      * Default constructor
      */
     public MultiByteFont() {
@@ -133,12 +134,16 @@
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    public boolean isEmbeddable() {
-        return !(getEmbedFileName() == null && getEmbedResourceName() == null);
-    }
+    
+// Comment out - this overrides the value derived by TTFFile, which 
+// is not what we want.    
+    
+//    /**
+//     * {@inheritDoc}
+//     */
+//    public boolean isEmbeddable() {
+//        return !(getEmbedFileName() == null && getEmbedResourceName() == null);
+//    }
 
     /**
      * {@inheritDoc}
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/Panose.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/Panose.java	(revision 0)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/Panose.java	(revision 0)
@@ -0,0 +1,391 @@
+/*
+ * Copyright 2006 The FOray Project.
+ *      http://www.foray.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This work is in part derived from the following work(s), used with the
+ * permission of the licensor:
+ *      Apache FOP, licensed by the Apache Software Foundation
+ *
+ */
+
+/*
+ * $LastChangedRevision: 10097 $
+ * $LastChangedDate: 2007-07-24 15:05:09 -0600 (Tue, 24 Jul 2007) $
+ * $LastChangedBy$
+ */
+
+package org.apache.fop.fonts;
+
+
+/**
+ * A PANOSE classification number.
+ * 
+ * <p>References:</p>
+ * <ul>
+ *   <li><a href="http://fonts.apple.com/TTRefMan/RM06/Chap6OS2.html">The TTF OS/2 Table
+ * doc</a></li>
+ *   <li><a href="http://www.w3.org/Fonts/Panose/pan2.html#StaticDigits">Panose 2.0 White
+ * Paper</a></li>
+ *   <li><a href="http://www.byte.com/art/9405/sec12/art1.htm">The Panose Typeface-Matching
+ * System</a></li>
+ *   <li>Michael S. De Laurentis, PANOSE 1.0 Core Mapper Services, Hewlett-Packard Document
+ * EWC-93-0023b, Hewlett-Packard Corporation, 101 Stewart, Suite 700, Seattle, WA 98101 (1993).</li>
+ *   <li><a href="www.fonts.com/hp/panose/greybook">The "Grey Book"</a></li>
+ * </ul>
+ */
+public class Panose {
+
+    /**
+     * Enumeration of the fields that comprise a PANOSE description.
+     * @see "http://fonts.apple.com/TTRefMan/RM06/Chap6OS2.html"
+     */
+    public enum Field {
+        /** The bFamilyType field. */
+        FAMILY_TYPE ((byte) 0, (byte) 5),
+
+        /** The bSerifStyle field. */
+        SERIF_STYLE ((byte) 1, (byte) 15),
+
+        /** The bWeight field. */
+        WEIGHT ((byte) 2, (byte) 11),
+
+        /** The bProportion field. */
+        PROPORTION ((byte) 3, (byte) 9),
+
+        /** The bContrast field. */
+        CONTRAST ((byte) 4, (byte) 9),
+
+        /** The bStrokeVariatoon field. */
+        STROKE_VARIATION ((byte) 5, (byte) 8),
+
+        /** The bArmStyle field. */
+        ARM_STYLE ((byte) 6, (byte) 11),
+
+        /** The bLetterform field. */
+        LETTERFORM ((byte) 7, (byte) 15),
+
+        /** The bMidline field. */
+        MIDLINE ((byte) 8, (byte) 13),
+
+        /** The bXHeight field. */
+        X_HEIGHT ((byte) 9, (byte) 7);
+
+        /** The 0-based index of this element in the PANOSE array. */
+        private byte index;
+
+        /** The maximum value that is permissible for this element. */
+        private byte maxValue;
+
+        /**
+         * Private Constructor.
+         * @param index The 0-based index of this element in the PANOSE array.
+         * @param maxValue The maximum value that is permissible for this element.
+         */
+        private Field(final byte index, final byte maxValue) {
+            this.index = index;
+            this.maxValue = maxValue;
+        }
+
+        /**
+         * Returns the 0-based index of this element in the PANOSE array.
+         * @return The 0-based index of this element in the PANOSE array.
+         */
+        public byte getIndex() {
+            return this.index;
+        }
+
+        /**
+         * Returns the maximum valid value for this field.
+         * @return The maximum valid value for this field.
+         */
+        public byte getMaxValue() {
+            return this.maxValue;
+        }
+
+    }
+	
+    /** An array of weights indicating that all elements in a comparison between two PANOSE values
+     * shall be considered to be of the same weight. */
+    private static final byte[] NEUTRAL_WEIGHTS = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+    /* Caveat: It is tempting to make NEUTRAL_WEIGHTS public and allow client apps to use it as a
+     * parameter. However, there is no way to protect the data inside it from corruption, so we
+     * have elected to keep it private and to allow "null" to be interpreted as the same value. */
+	
+//    /** Constant indicating the size of the "panose" field, in bytes. */
+//    public static final byte ARRAY_SIZE = 10;
+
+    /** Max difference for it to be considered an acceptable match.
+     *  Note that this value will depend on the weights in the
+     *  difference function.
+     */ 
+    public static final int MATCH_THRESHOLD = 30;
+    
+    
+    /** The encapsulated array of PANOSE numbers. */
+    private byte[] panoseArray;
+    
+
+    /**
+     * Private Constructor. Use {@link #makeInstance(byte[])} to create an instance of this class.
+     * @param panoseArray The array of bytes recording the PANOSE classification.
+     */
+    private Panose(final byte[] panoseArray) {
+        this.panoseArray = panoseArray;
+    }
+
+    /**
+     * Creates a new Panose instance.
+     * @param panoseArray The array of bytes recording the PANOSE
+     * classification.
+     * @return The newly-created instance.
+     */
+    public static Panose makeInstance(final byte[] panoseArray) {
+        final String panoseValidationMessage = Panose.validPanose(panoseArray);
+        if (panoseValidationMessage != null) {
+            throw new IllegalArgumentException("Illegal Panose Array: " + panoseValidationMessage);
+        }
+        return new Panose(panoseArray);
+    }
+
+    /**
+     * Returns a clone of the the array of bytes representing the PANOSE number.
+     * To avoid the cost of this cloning operation, use {@link #getElement(int)} to obtain the
+     * value of individual elements in the array.
+     * @return The PANOSE array.
+     */
+    public byte[] getPanoseArray() {
+        return this.panoseArray.clone();
+    }
+
+    /**
+     * Returns a given element from the underlying Panose array.
+     * @param index The index to the element desired.
+     * @return The value of the element at <code>index</code>.
+     */
+    public byte getElement(final int index) {
+        return this.panoseArray[index];
+    }
+
+    /**
+     * Returns a given element from the underlying Panose array.
+     * @param field The field for which the value is desired.
+     * @return The value of the element at <code>field</code>.
+     */
+    public byte getElement(final Panose.Field field) {
+        final int index = field.getIndex();
+        return getElement(index);
+    }
+
+    /**
+     * Computes the weighted "closeness" of another Panose to this value.
+     * @param otherPanose Another Panose instance which is being compared to this.
+     * @param weights 10-element byte array of weights that should be used for each of the elements
+     * in the comparison.
+     * Values in this array must be between 0 and 127 inclusive.
+     * (This constant is documented at http://www.w3.org/Fonts/Panose/pan2.html#StaticDigits).
+     * Use null if all elements are to be weighted equally.
+     * @return The weighted difference between the two Panose values.
+     * A smaller value indicates that the two values are closer, and a larger
+     * value indicates that they are farther apart.
+     */
+    public long difference(final Panose otherPanose, final byte[] weights) {
+        /* This is a partial implementation of the "PANOSE Matching Heuristic" documented at:
+         * http://www.w3.org/Fonts/Panose/pan2.html#Heuristic. **/
+        byte[] weightsToUse = null;
+        if (weights == null) {
+            weightsToUse = Panose.NEUTRAL_WEIGHTS;
+        } else {
+            validateWeights(weights);
+            weightsToUse = weights;
+        }
+        long difference = 0;
+        for (int i = 0; i < Panose.Field.values().length; i++) {
+//            final int digit = panoseDescription.length - i;
+//            final int weight = (int) Math.round(Math.pow(2, digit - 1));
+            final int weight = weightsToUse[i];
+
+            final int thisDifference = this.getElement(i) - otherPanose.getElement(i);
+            difference += weight * thisDifference * thisDifference;
+        }
+        return difference;
+    }
+    
+    /*
+     *  consolas           [ 2 11 6 9 2 2 4 3 2 4 ] bold 6 ital 3
+		consolas-bold      [ 2 11 7 9 2 2 4 3 2 4 ] bold 7 ital 3
+		consolas-italic    [ 2 11 6 9 2 2 4 10 2 4 ] bold 6 ital 10
+		consolas-bolditalic[ 2 11 7 9 2 2 4 10 2 4 ] bold 7 ital 10
+		
+		cordianew           [ 2 11 3 4 2 2 2 2 2 4 ] bold 3 ital 2
+		cordianew-bolditalic[ 2 11 6 4 2 2 2 9 2 4 ] bold 6 ital 9
+		
+		calibri             [ 2 15 5 2 2 2 4 3 2 4 ] bold 5 ital 3
+		calibri-bold        [ 2 15 7 2 3 4 4 3 2 4 ] bold 7 ital 3
+		calibri-bolditalic  [ 2 15 7 2 3 4 4 10 2 4 ] bold 7 ital 10
+		
+		constantia          [ 2 3 6 2 5 3 6 3 3 3 ] bold 6 ital 3
+		constantia-bold     [ 2 3 7 2 6 3 6 3 3 3 ] bold 7 ital 3
+		                              ^ note this
+		constantia-italic   [ 2 3 6 2 5 3 6 10 3 3 ] bold 6 ital 10
+		
+		candara-bold        [ 2 14 7 2 3 3 3 2 2 4 ] bold 7 ital 2
+		candara-italic      [ 2 14 5 2 3 3 3 9 2 4 ] bold 5 ital 9
+		candara-bolditalic  [ 2 14 7 2 3 3 3 9 2 4 ] bold 7 ital 9
+		
+		cambria-bold        [ 2 4 8 3 5 4 6 3 2 4 ] bold 8 ital 3
+		cambria-italic      [ 2 4 5 3 5 4 6 10 2 4 ] bold 5 ital 10
+
+     */
+    
+    public static Panose getBold(Panose thisPanose) {
+    	
+    	byte[] panoseArray = thisPanose.getPanoseArray();
+    	
+    	if (panoseArray[2]==11) {
+    		// Already the maximum value - do nothing
+    	} else if (panoseArray[2]<8) {
+    		panoseArray[2]=7; // 8 = bold, but most of the MS ClearType Collection fonts have 7 here.
+    	} else {
+    		// Do nothing, rather than increase the Weight
+    	}
+    	
+		return Panose.makeInstance(panoseArray);
+    	
+    }
+
+    public static Panose getItalic(Panose thisPanose) {
+    	
+    	byte[] panoseArray = thisPanose.getPanoseArray();
+    	
+    	if (panoseArray[7]==15) {
+    		// Already the maximum value - do nothing
+    	} else if (panoseArray[7]<9) {
+    		panoseArray[7]=9; // Most fonts have 9 or 10 here.
+    	} else {
+    		// Do nothing, rather than increase the Letterform setting 
+    	}
+    	
+		return Panose.makeInstance(panoseArray);
+    	
+    }
+    
+    
+    /**
+     * Examines an array of weights, throwing various unchecked exceptions if the data is not valid.
+     * @param weights The array of weights to be tested.
+     */
+    private static void validateWeights(final byte[] weights) {
+        if (weights == null) {
+            throw new NullPointerException("Weights may not be null");
+        }
+        if (weights.length != Panose.Field.values().length) {
+            throw new IllegalArgumentException("Weights size expected: "
+                    + Panose.Field.values().length + ", actual: " + weights.length);
+        }
+        for (int i = 0; i < weights.length; i++) {
+            final byte weight = weights[i];
+            if (weight < 0
+                    || weight > Byte.MAX_VALUE) {
+                throw new IllegalArgumentException("Weight element " + i + " is outside the range "
+                        + "of 0 thru 127.");
+            }
+        }
+    }
+    
+//    /**
+//     * Tests the validity of a panose description.
+//     * @param panoseDescription The panose values to be tested.
+//     * @return True for a valid PANOSE description, or false if the input is
+//     * null, does not have 10 elements, or any of the elements do not contain
+//     * valid ASCII numerals (0 through 9).
+//     */
+//    public static boolean validPanose(final byte[] panoseDescription) {
+//        if (panoseDescription == null) {
+//        	System.out.println("null byte[]" );
+//            return false;
+//        }
+//        if (panoseDescription.length != Panose.ARRAY_SIZE) {
+//        	System.out.println("Invalid length " + panoseDescription.length );
+//            return false;
+//        }
+//        for (int i = 0; i < panoseDescription.length; i++) {
+//            final byte theByte = panoseDescription[i];
+//            String s = Byte.toString(theByte);            
+//            int n = Integer.parseInt(s);
+//            if (n < 0) {
+//            	//System.out.println("Invalid value (too small) " + theByte + " in position " + i + " of " + toString(panoseDescription) );
+//                return false;
+//            }
+//                        
+//            if (n > validMaxValues[i]) {
+//            	System.out.println("Invalid value " + n + " > " + validMaxValues[i] + " in position " + i + " of " + toString(panoseDescription) );
+//                return false;
+//            }
+//        }
+//        return true;
+//    }
+
+    
+    
+    /**
+     * Tests the validity of a panose description.
+     * @param panoseDescription The panose values to be tested.
+     * @return Null for a valid PANOSE description. For an invalid PANOSE description, returns a
+     * descriptive message indicating which element is invalid.
+     */
+    public static String validPanose(final byte[] panoseDescription) {
+        if (panoseDescription == null) {
+            return "Panose description cannot be null.";
+        }
+        if (panoseDescription.length != Panose.Field.values().length) {
+            return "Illegal Panose description size: " + panoseDescription.length;
+        }
+        for (int i = 0; i < panoseDescription.length; i++) {
+            final byte theByte = panoseDescription[i];
+            final Panose.Field panoseField = Panose.Field.values()[i];
+            final byte maxValue = panoseField.getMaxValue();
+            if (theByte < 0
+                    || theByte > maxValue) {
+                return "Invalid value " + theByte + " > " + maxValue + " in position " + i
+                        + " of " + toString(panoseDescription);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public String toString() {
+        return toString(this.panoseArray);      
+    }
+
+    /**
+     * Returns a String representation of a Panose array.
+     * @param panoseArray The Panose array to be expressed as a String.
+     * @return The String representation of <code>panoseArray</code>.
+     */
+    private static String toString(final byte[] panoseArray) {
+        final StringBuilder sb = new StringBuilder(30);
+        sb.append("[ ");
+        for (int i = 0; i < panoseArray.length; i++) {
+            final byte theByte = panoseArray[i];
+            sb.append(theByte + " ");
+        }
+        sb.append("]");
+        return sb.toString();       
+    }
+    
+}
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFile.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFile.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFile.java	(working copy)
@@ -31,6 +31,7 @@
 import org.apache.xmlgraphics.fonts.Glyphs;
 
 import org.apache.fop.fonts.FontUtil;
+import org.apache.fop.fonts.Panose;
 
 /**
  * Reads a TrueType file or a TrueType Collection.
@@ -48,9 +49,12 @@
     public static final boolean TRACE_ENABLED = false;
 
     private String encoding = "WinAnsiEncoding";    // Default encoding
+    
+    /** Array containing the Panose information. */
+    private Panose panose;
 
     private short firstChar = 0;
-    private boolean isEmbeddable = true;
+    private boolean isEmbeddable = false; // until proven otherwise!
     private boolean hasSerifs = true;
     /**
      * Table directory
@@ -549,8 +553,10 @@
      */
     public String getPostScriptName() {
         if (postScriptName.length() == 0) {
+        	System.out.println("TTFFile - Hmmm, Composed postscript name from fullname.");
             return FontUtil.stripWhiteSpace(getFullName());
         } else {
+//        	System.out.println("TTFFile - Cool, there was a proper postScript name, namely: " + postScriptName);
             return postScriptName;
         }
     }
@@ -743,6 +749,7 @@
      * @return boolean True if it may be embedded
      */
     public boolean isEmbeddable() {
+    	
         return isEmbeddable;
     }
 
@@ -988,7 +995,10 @@
         if (dirTabs.get("OS/2") != null) {
             seekTab(in, "OS/2", 2 * 2);
             this.usWeightClass = in.readTTFUShort();
+            
+            // usWidthClass
             in.skip(2);
+            
             int fsType = in.readTTFUShort();
             if (fsType == 2) {
                 isEmbeddable = false;
@@ -996,10 +1006,21 @@
                 isEmbeddable = true;
             }
             in.skip(11 * 2);
-            in.skip(10); //panose array
+            
+            //in.skip(10); //panose array
+            final byte[] panoseArray = new byte[10];
+            for (int i = 0; i < panoseArray.length; i++) {
+                panoseArray[i] = in.read();
+            }
+            this.panose = Panose.makeInstance(panoseArray);
+            
+            
+            /* Skip ulUnicodeRange1 - 4. */            
             in.skip(4 * 4); //unicode ranges
             in.skip(4);
             in.skip(3 * 2);
+           
+            /* Read sTypoAscender. */            
             int v;
             os2Ascender = in.readTTFShort(); //sTypoAscender
             log.debug("sTypoAscender: " + os2Ascender 
@@ -1568,4 +1589,8 @@
             ioe.printStackTrace(System.err);
         }
     }
+
+	public Panose getPanose() {
+		return panose;
+	}
 }
\ No newline at end of file
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFontLoader.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFontLoader.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFontLoader.java	(working copy)
@@ -92,6 +92,9 @@
         returnFont.setMissingWidth(0);
         returnFont.setWeight(ttf.getWeightClass());
         
+        returnFont.setPanose(ttf.getPanose() );
+        returnFont.setEmbeddable(ttf.isEmbeddable() );
+        
         multiFont.setCIDType(CIDFontType.CIDTYPE2);
         int[] wx = ttf.getWidths();
         multiFont.setWidthArray(wx);
