Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/autodetect/FontFileFinder.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/autodetect/FontFileFinder.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/autodetect/FontFileFinder.java	(working copy)
@@ -78,8 +78,7 @@
     protected static IOFileFilter getFileFilter() {
         return FileFilterUtils.andFileFilter(
                 FileFilterUtils.fileFileFilter(),
-                new WildcardFileFilter(new String[] {"*.ttf", "*.otf", "*.pfb"}, IOCase.INSENSITIVE)
-                //TODO Add *.ttc when support for it has been added to the auto-detection mech.
+                new WildcardFileFilter(new String[] {"*.ttf", "*.otf", "*.pfb", "*.ttc"}, IOCase.INSENSITIVE)
         );
     }
     
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/autodetect/FontInfoFinder.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/autodetect/FontInfoFinder.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/autodetect/FontInfoFinder.java	(working copy)
@@ -20,8 +20,10 @@
 package org.apache.fop.fonts.autodetect;
 
 import java.io.IOException;
+import java.io.InputStream;
 import java.net.URL;
 import java.net.URLConnection;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -41,6 +43,9 @@
 import org.apache.fop.fonts.FontResolver;
 import org.apache.fop.fonts.FontTriplet;
 import org.apache.fop.fonts.FontUtil;
+import org.apache.fop.fonts.truetype.FontFileReader;
+import org.apache.fop.fonts.truetype.TTFFile;
+import org.apache.fop.fonts.truetype.TTFFontLoader;
 
 /**
  * Attempts to determine correct FontInfo
@@ -62,11 +67,47 @@
             log.trace("Font: " + customFont.getFullName() 
                     + ", family: " + customFont.getFamilyNames() 
                     + ", PS: " + customFont.getFontName() 
-                    + ", EmbedName: " + customFont.getEmbedFontName());
+                    + ", EmbedName: " + customFont.getEmbedFontName()
+                    + ", subFamily: " + customFont.getFontSubName()                    
+            );
         }
 
+//System.out.println("Font: " + customFont.getFullName() 
+//                + ", family: " + customFont.getFamilyNames() 
+//                + ", PS: " + customFont.getFontName() 
+//                //+ ", EmbedName: " + customFont.getEmbedFontName() //Same as getFontName
+//                //+ ", subFamily: " + customFont.getFontSubName()  // Seems to be null always                  
+//        );
+        
+        /* Examples:
+         * 
+         * Font: URW Bookman L Demi Bold Italic, family: [URW Bookman L], PS: URWBookmanL-DemiBoldItal, EmbedName: URWBookmanL-DemiBoldItal, subFamily: null
+
+Font: Century Schoolbook L Bold, family: [Century Schoolbook L], PS: CenturySchL-Bold, EmbedName: CenturySchL-Bold, subFamily: null
+
+			Examples of family names (note the square brackets):
+			
+				Font: , family: [DejaVu Sans]
+				Font: , family: [OpenSymbol]
+				Font: , family: [Cambria]
+				Font: , family: [Calibri]
+				Font: , family: [Times New Roman]
+				Font: , family: [FreeMono]
+			
+			Multiple values are comma separated.
+			
+				Font: , family: [DejaVu Sans Condensed, DejaVu Sans]
+				Font: , family: [Hor, ae_Hor]
+				Font: , family: [padmaa-Bold.1.1, padmaa, padmmaa]
+
+         * 
+         */
+                
         // default style and weight triplet vales (fallback)
         String strippedName = stripQuotes(customFont.getStrippedFontName());
+        	// This is almost always the PS name
+        
+        
         //String subName = customFont.getFontSubName();
         String fullName = stripQuotes(customFont.getFullName());
         String searchName = fullName.toLowerCase();
@@ -81,9 +122,10 @@
         //Full Name usually includes style/weight info so don't use these traits
         //If we still want to use these traits, we have to make FontInfo.fontLookup() smarter
         triplets.add(new FontTriplet(fullName, Font.STYLE_NORMAL, Font.WEIGHT_NORMAL, 0));
-        if (!fullName.equals(strippedName)) {
-            triplets.add(new FontTriplet(strippedName, Font.STYLE_NORMAL, Font.WEIGHT_NORMAL, 0));
-        }
+//        System.out.println( fullName + " -- full name");
+//        if (!fullName.equals(strippedName)) {
+//            triplets.add(new FontTriplet(strippedName, Font.STYLE_NORMAL, Font.WEIGHT_NORMAL, 0));
+//        }
         Set familyNames = customFont.getFamilyNames();
         Iterator iter = familyNames.iterator();
         while (iter.hasNext()) {
@@ -133,6 +175,9 @@
         embedUrl = fontUrl.toExternalForm();
         EmbedFontInfo fontInfo = new EmbedFontInfo(null, customFont.isKerningEnabled(),
                 fontTripletList, embedUrl);
+        fontInfo.setPanose(customFont.getPanose());
+        fontInfo.setEmbeddable(customFont.isEmbeddable());
+        fontInfo.setPostScriptName(customFont.getFontName());
         if (fontCache != null) {
             fontCache.addFont(fontInfo);
         }
@@ -145,12 +190,18 @@
      * @param fontUrl font URL. Assumed to be local.
      * @param resolver font resolver used to resolve font
      * @param fontCache font cache (may be null)
-     * @return newly created embed font info
+     * @return list of newly created embed font info.  Generally, this list
+     *         will have only one entry, unless the fontUrl is a TTC
      */
-    public EmbedFontInfo find(URL fontUrl, FontResolver resolver, FontCache fontCache) {
+    public List<EmbedFontInfo> find(URL fontUrl, FontResolver resolver, FontCache fontCache) {
+    	
+    	List<EmbedFontInfo> embedFontInfoList = new java.util.ArrayList<EmbedFontInfo>();
+    	
         String embedUrl = null;
         embedUrl = fontUrl.toExternalForm();
         
+        System.out.println(embedUrl);
+        
         long fileLastModified = -1;
         if (fontCache != null) {
             try {
@@ -168,13 +219,28 @@
             }
             // firstly try and fetch it from cache before loading/parsing the font file
             if (fontCache.containsFont(embedUrl)) {
-                CachedFontInfo fontInfo = fontCache.getFont(embedUrl);
-                if (fontInfo.lastModified() == fileLastModified) {
-                    return fontInfo;
+                
+                FontCache.CachedFontFile cachedFontInfos =  fontCache.getFontFile(embedUrl);
+                boolean allUpToDate = true; // until proven otherwise
+                for (CachedFontInfo fontInfo : cachedFontInfos.getFilefontsMap().values()) {
+                
+	                if (fontInfo.lastModified() == fileLastModified) {
+	                	embedFontInfoList.add(fontInfo);
+	                } else {
+	                    // out of date cache item
+	                    fontCache.removeFont(embedUrl);
+	                    allUpToDate = false;
+	                    continue;
+	                }
+                }
+                
+                if (allUpToDate) {
+                	return embedFontInfoList;
                 } else {
-                    // out of date cache item
-                    fontCache.removeFont(embedUrl);
+                	// Start again
+                	embedFontInfoList = new java.util.ArrayList<EmbedFontInfo>();                	
                 }
+                
             // is this a previously failed parsed font?
             } else if (fontCache.isFailedFont(embedUrl, fileLastModified)) {
                 if (log.isDebugEnabled()) {
@@ -184,20 +250,75 @@
             }
         }
         
+        
         // try to determine triplet information from font file
         CustomFont customFont = null;
-        try {
-            customFont = FontLoader.loadFont(fontUrl, resolver);
-        } catch (Exception e) {
-            //TODO Too verbose (it's an error but we don't care if some fonts can't be loaded)
-            if (log.isErrorEnabled()) {
-                log.error("Unable to load font file: " + embedUrl + ". Reason: " + e.getMessage());
+        
+        if (fontUrl.toExternalForm().endsWith(".ttc")) {
+        	
+        	// Get a list of the TTC Font names
+        	List<String> ttcNames = null;
+        	String fontFileURI = fontUrl.toExternalForm().trim();
+        	TTFFontLoader ttfLoader = new TTFFontLoader(fontFileURI, resolver);
+            InputStream in = null;         	
+            try {
+            	in = FontLoader.openFontUri(resolver, fontFileURI);
+                TTFFile ttf = new TTFFile();
+                FontFileReader reader = new FontFileReader(in);
+                ttcNames = ttf.getTTCnames(reader);
+            } catch (Exception e) {
+            	log.error(e);
+            } finally {
+                IOUtils.closeQuietly(in);
             }
-            if (fontCache != null) {
-                fontCache.registerFailedFont(embedUrl, fileLastModified);
+        	
+        	// For each font name ...
+        	for (String fontName : ttcNames) {
+
+        		log.debug("Loading " + fontName);
+	            try {
+	            	ttfLoader = new TTFFontLoader(fontFileURI, resolver);
+	                ttfLoader.read(fontName);
+	                customFont = ttfLoader.getFont();
+	            } catch (Exception e) {
+	                //TODO Too verbose (it's an error but we don't care if some fonts can't be loaded)
+	                //if (log.isErrorEnabled()) {
+	                    log.error("Unable to load font file: " + embedUrl + ". Reason: " + e.getMessage());
+	                //}
+	                if (fontCache != null) {
+	                    fontCache.registerFailedFont(embedUrl, fileLastModified);
+	                }
+	                continue;
+	            }
+	            EmbedFontInfo fi = fontInfoFromCustomFont(fontUrl, customFont, fontCache);
+	            if (fi!=null) {
+	            	embedFontInfoList.add(fi);
+	            } 
+        	}
+        	return embedFontInfoList;
+        } else {
+        	// The normal case
+            try {
+                customFont = FontLoader.loadFont(fontUrl, resolver);
+            } catch (Exception e) {
+                //TODO Too verbose (it's an error but we don't care if some fonts can't be loaded)
+                //if (log.isErrorEnabled()) {
+                    log.error("Unable to load font file: " + embedUrl + ". Reason: " + e.getMessage());
+                //}
+                if (fontCache != null) {
+                    fontCache.registerFailedFont(embedUrl, fileLastModified);
+                }
+                return null;
             }
-            return null;
+            EmbedFontInfo fi = fontInfoFromCustomFont(fontUrl, customFont, fontCache);
+            if (fi!=null) {
+            	embedFontInfoList.add(fi);
+                return embedFontInfoList;        	
+            } else {
+            	return null;
+            }        	
         }
-        return fontInfoFromCustomFont(fontUrl, customFont, fontCache);     
+        
+
     }
 }
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/CachedFontInfo.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/CachedFontInfo.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/CachedFontInfo.java	(working copy)
@@ -86,6 +86,12 @@
      */
     public CachedFontInfo(EmbedFontInfo fontInfo) {
         super(fontInfo.metricsFile, fontInfo.kerning, fontInfo.fontTriplets, fontInfo.embedFile);
+        
+        // We need to cache our extra stuff as well!
+        setEmbeddable(fontInfo.isEmbeddable());
+        setPanose(fontInfo.getPanose());
+        setPostScriptName(fontInfo.getPostScriptName());        
+        
         // try and determine modified date
         File fontFile = getFileFromUrls(new String[] {embedFile, metricsFile});
         if (fontFile != null ) {
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/CustomFont.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/CustomFont.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/CustomFont.java	(working copy)
@@ -57,6 +57,26 @@
     private Map kerning;
 
     private boolean useKerning = true;
+    
+    private boolean isEmbeddable = true; 
+	public boolean isEmbeddable() {
+		return isEmbeddable;
+	}
+	public void setEmbeddable(boolean isEmbeddable) {
+		this.isEmbeddable = isEmbeddable;
+	}
+    
+    
+    private Panose panose = null;
+
+    public Panose getPanose() {
+		return panose;
+	}
+
+	public void setPanose(Panose panose) {
+		this.panose = panose;
+	}
+    
 
     /** {@inheritDoc} */
     public String getFontName() {
@@ -448,4 +468,5 @@
         }
     }
 
+
 }
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/EmbedFontInfo.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/EmbedFontInfo.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/EmbedFontInfo.java	(working copy)
@@ -38,6 +38,32 @@
     protected boolean kerning;
     /** the list of associated font triplets */
     protected List fontTriplets;
+    
+    private boolean isEmbeddable = true; 
+	public boolean isEmbeddable() {
+		return isEmbeddable;
+	}
+	public void setEmbeddable(boolean isEmbeddable) {
+		this.isEmbeddable = isEmbeddable;
+	}    
+    
+    protected Panose panose = null;
+
+    public Panose getPanose() {
+		return panose;
+	}
+
+	public void setPanose(Panose panose) {
+		this.panose = panose;
+	}
+    
+	protected String postScriptName = null;
+	public String getPostScriptName() {
+		return postScriptName;
+	}
+	public void setPostScriptName(String postScriptName) {
+		this.postScriptName = postScriptName;
+	}
       
     /**
      * Main constructor
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/FontCache.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/FontCache.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/FontCache.java	(working copy)
@@ -27,6 +27,9 @@
 import java.io.OutputStream;
 import java.io.Serializable;
 import java.util.Map;
+import java.util.ArrayList;
+import java.util.List;
+
 
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.logging.Log;
@@ -61,11 +64,15 @@
     /** change lock */
     private transient Object changeLock = new Object();
     
-    /** master mapping of font url -> font info */
-    private Map fontMap = new java.util.HashMap();
+    /** master mapping of font url -> font info.  This needs to be
+     *  a list, since a TTC file may contain more than 1 font. */
+    private Map<String, CachedFontFile> fontfileMap 
+    			= new java.util.HashMap<String, CachedFontFile>();
 
     /** mapping of font url -> file modified date */
     private Map failedFontMap = new java.util.HashMap();
+	// Really, its a failed URL map
+
 
     /**
      * Default constructor
@@ -216,7 +223,7 @@
      */
     public boolean containsFont(String embedUrl) {
         if (embedUrl != null) {
-            return fontMap.containsKey(embedUrl);
+            return fontfileMap.containsKey(embedUrl);
         }
         return false;
     }
@@ -228,7 +235,7 @@
      */
     public boolean containsFont(EmbedFontInfo fontInfo) {
         if (fontInfo != null) {
-            return fontMap.containsKey(getCacheKey(fontInfo));
+            return fontfileMap.containsKey(getCacheKey(fontInfo));
         }
         return false;
     }
@@ -240,7 +247,14 @@
     public void addFont(EmbedFontInfo fontInfo) {
         String cacheKey = getCacheKey(fontInfo);
         synchronized (changeLock) {
-            if (!containsFont(cacheKey)) {
+        	CachedFontFile cachedFontFile;
+        	if (containsFont(cacheKey)) {
+        		cachedFontFile = fontfileMap.get(cacheKey);        		
+        		if (!cachedFontFile.containsFont(fontInfo.getPostScriptName() ) ) {
+        			cachedFontFile.put(new CachedFontInfo(fontInfo));	
+        		}        	
+        	} else {
+        		cachedFontFile = new CachedFontFile();
                 if (log.isTraceEnabled()) {
                     log.trace("Font added to cache: " + cacheKey);
                 }
@@ -245,10 +259,11 @@
                     log.trace("Font added to cache: " + cacheKey);
                 }
                 if (fontInfo instanceof CachedFontInfo) {
-                    fontMap.put(cacheKey, fontInfo);
+                	cachedFontFile.put((CachedFontInfo)fontInfo);
                 } else {
-                    fontMap.put(cacheKey, new CachedFontInfo(fontInfo));
+                	cachedFontFile.put(new CachedFontInfo(fontInfo));                	
                 }
+                fontfileMap.put(cacheKey, cachedFontFile);
                 changed = true;
             }
         }
@@ -257,11 +272,11 @@
     /**
      * returns a font from the cache
      * @param embedUrl font info
-     * @return boolean
+     * @return CachedFontFile object 
      */
-    public CachedFontInfo getFont(String embedUrl) {
+    public CachedFontFile getFontFile(String embedUrl) {
         if (containsFont(embedUrl)) {
-            return (CachedFontInfo)fontMap.get(embedUrl);
+            return fontfileMap.get(embedUrl);
         }
         return null;
     }
@@ -276,7 +291,7 @@
                 if (log.isTraceEnabled()) {
                     log.trace("Font removed from cache: " + embedUrl);
                 }
-                fontMap.remove(embedUrl);
+                fontfileMap.remove(embedUrl);
                 changed = true;
             }
         }
@@ -289,6 +304,7 @@
      * @return whether this is a failed font
      */
     public boolean isFailedFont(String embedUrl, long lastModified) {
+    	    	
         if (failedFontMap.containsKey(embedUrl)) {
             synchronized (changeLock) {
                 long failedLastModified = ((Long)failedFontMap.get(embedUrl)).longValue();
@@ -326,7 +342,7 @@
             if (log.isTraceEnabled()) {
                 log.trace("Font cache cleared.");
             }
-            fontMap.clear();
+            fontfileMap.clear();
             failedFontMap.clear();
             changed = true;
         }
@@ -331,4 +347,27 @@
             changed = true;
         }
     }
+    
+    public class CachedFontFile implements Serializable {
+    	
+        private Map<String, CachedFontInfo> filefontsMap 
+			= new java.util.HashMap<String, CachedFontInfo>();
+        
+        void put(CachedFontInfo efi) {
+        	filefontsMap.put(efi.getPostScriptName(), efi);
+        }
+    	
+        public boolean containsFont(String fontName) {
+            if (fontName != null) {
+                return filefontsMap.containsKey(fontName);
+            }
+            return false;
+        }
+
+		public Map<String, CachedFontInfo> getFilefontsMap() {
+			return filefontsMap;
+		}
+        
+    	
+    }
 }
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/FontLoader.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/FontLoader.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/FontLoader.java	(working copy)
@@ -121,7 +121,7 @@
      * @throws IOException In case of an I/O error
      * @throws MalformedURLException If an invalid URL is built
      */
-    protected static InputStream openFontUri(FontResolver resolver, String uri) 
+    public static InputStream openFontUri(FontResolver resolver, String uri) 
                     throws IOException, MalformedURLException {
         InputStream in = null;
         if (resolver != null) {
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/MultiByteFont.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/MultiByteFont.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/MultiByteFont.java	(working copy)
@@ -40,8 +40,9 @@
     private String namePrefix = null;    // Quasi unique prefix
 
     private BFEntry[] bfentries = null;
+    
 
-    /**
+	/**
      * Default constructor
      */
     public MultiByteFont() {
@@ -133,12 +134,16 @@
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    public boolean isEmbeddable() {
-        return !(getEmbedFileName() == null && getEmbedResourceName() == null);
-    }
+    
+// Comment out - this overrides the value derived by TTFFile, which 
+// is not what we want.    
+    
+//    /**
+//     * {@inheritDoc}
+//     */
+//    public boolean isEmbeddable() {
+//        return !(getEmbedFileName() == null && getEmbedResourceName() == null);
+//    }
 
     /**
      * {@inheritDoc}
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/Panose.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/Panose.java	(revision 0)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/Panose.java	(revision 0)
@@ -0,0 +1,404 @@
+/*
+ * Copyright 2006 The FOray Project.
+ *      http://www.foray.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This work is in part derived from the following work(s), used with the
+ * permission of the licensor:
+ *      Apache FOP, licensed by the Apache Software Foundation
+ *
+ */
+
+/*
+ * $LastChangedRevision: 10097 $
+ * $LastChangedDate: 2007-07-24 15:05:09 -0600 (Tue, 24 Jul 2007) $
+ * $LastChangedBy$
+ */
+
+package org.apache.fop.fonts;
+
+import java.io.Serializable;
+
+
+/**
+ * A PANOSE classification number.
+ * 
+ * <p>References:</p>
+ * <ul>
+ *   <li><a href="http://fonts.apple.com/TTRefMan/RM06/Chap6OS2.html">The TTF OS/2 Table
+ * doc</a></li>
+ *   <li><a href="http://www.w3.org/Fonts/Panose/pan2.html#StaticDigits">Panose 2.0 White
+ * Paper</a></li>
+ *   <li><a href="http://www.byte.com/art/9405/sec12/art1.htm">The Panose Typeface-Matching
+ * System</a></li>
+ *   <li>Michael S. De Laurentis, PANOSE 1.0 Core Mapper Services, Hewlett-Packard Document
+ * EWC-93-0023b, Hewlett-Packard Corporation, 101 Stewart, Suite 700, Seattle, WA 98101 (1993).</li>
+ *   <li><a href="www.fonts.com/hp/panose/greybook">The "Grey Book"</a></li>
+ * </ul>
+ */
+public class Panose implements Serializable {
+
+    /**
+     * Serialization Version UID. Change this value if you want to make sure the user's cache
+     * file is purged after an update.
+     */
+    private static final long serialVersionUID = 605232520271754718L;
+	
+    /**
+     * Enumeration of the fields that comprise a PANOSE description.
+     * @see "http://fonts.apple.com/TTRefMan/RM06/Chap6OS2.html"
+     */
+    public enum Field {
+        /** The bFamilyType field. */
+        FAMILY_TYPE ((byte) 0, (byte) 5),
+
+        /** The bSerifStyle field. */
+        SERIF_STYLE ((byte) 1, (byte) 15),
+
+        /** The bWeight field. */
+        WEIGHT ((byte) 2, (byte) 11),
+
+        /** The bProportion field. */
+        PROPORTION ((byte) 3, (byte) 9),
+
+        /** The bContrast field. */
+        CONTRAST ((byte) 4, (byte) 9),
+
+        /** The bStrokeVariatoon field. */
+        STROKE_VARIATION ((byte) 5, (byte) 8),
+
+        /** The bArmStyle field. */
+        ARM_STYLE ((byte) 6, (byte) 11),
+
+        /** The bLetterform field. */
+        LETTERFORM ((byte) 7, (byte) 15),
+
+        /** The bMidline field. */
+        MIDLINE ((byte) 8, (byte) 13),
+
+        /** The bXHeight field. */
+        X_HEIGHT ((byte) 9, (byte) 7);
+
+        /** The 0-based index of this element in the PANOSE array. */
+        private byte index;
+
+        /** The maximum value that is permissible for this element. */
+        private byte maxValue;
+
+        /**
+         * Private Constructor.
+         * @param index The 0-based index of this element in the PANOSE array.
+         * @param maxValue The maximum value that is permissible for this element.
+         */
+        private Field(final byte index, final byte maxValue) {
+            this.index = index;
+            this.maxValue = maxValue;
+        }
+
+        /**
+         * Returns the 0-based index of this element in the PANOSE array.
+         * @return The 0-based index of this element in the PANOSE array.
+         */
+        public byte getIndex() {
+            return this.index;
+        }
+
+        /**
+         * Returns the maximum valid value for this field.
+         * @return The maximum valid value for this field.
+         */
+        public byte getMaxValue() {
+            return this.maxValue;
+        }
+
+    }
+	
+    /** An array of weights indicating that all elements in a comparison between two PANOSE values
+     * shall be considered to be of the same weight. */
+    private static final byte[] NEUTRAL_WEIGHTS = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+    /* Caveat: It is tempting to make NEUTRAL_WEIGHTS public and allow client apps to use it as a
+     * parameter. However, there is no way to protect the data inside it from corruption, so we
+     * have elected to keep it private and to allow "null" to be interpreted as the same value. */
+	
+//    /** Constant indicating the size of the "panose" field, in bytes. */
+//    public static final byte ARRAY_SIZE = 10;
+
+    /** Max difference for it to be considered an acceptable match.
+     *  Note that this value will depend on the weights in the
+     *  difference function.
+     */ 
+    public static final int MATCH_THRESHOLD = 30;
+    
+    
+    /** The encapsulated array of PANOSE numbers. */
+    private byte[] panoseArray;
+    
+
+    /**
+     * Private Constructor. Use {@link #makeInstance(byte[])} to create an instance of this class.
+     * @param panoseArray The array of bytes recording the PANOSE classification.
+     */
+    private Panose(final byte[] panoseArray) {
+        this.panoseArray = panoseArray;
+    }
+
+    /**
+     * Creates a new Panose instance.
+     * @param panoseArray The array of bytes recording the PANOSE
+     * classification.
+     * @return The newly-created instance.
+     */
+    public static Panose makeInstance(final byte[] panoseArray) {
+        final String panoseValidationMessage = Panose.validPanose(panoseArray);
+        if (panoseValidationMessage != null) {
+            throw new IllegalArgumentException("Illegal Panose Array: " + panoseValidationMessage);
+        }
+        return new Panose(panoseArray);
+    }
+
+    /**
+     * Returns a clone of the the array of bytes representing the PANOSE number.
+     * To avoid the cost of this cloning operation, use {@link #getElement(int)} to obtain the
+     * value of individual elements in the array.
+     * @return The PANOSE array.
+     */
+    public byte[] getPanoseArray() {
+        return this.panoseArray.clone();
+    }
+
+    /**
+     * Returns a given element from the underlying Panose array.
+     * @param index The index to the element desired.
+     * @return The value of the element at <code>index</code>.
+     */
+    public byte getElement(final int index) {
+        return this.panoseArray[index];
+    }
+
+    /**
+     * Returns a given element from the underlying Panose array.
+     * @param field The field for which the value is desired.
+     * @return The value of the element at <code>field</code>.
+     */
+    public byte getElement(final Panose.Field field) {
+        final int index = field.getIndex();
+        return getElement(index);
+    }
+
+    /**
+     * Computes the weighted "closeness" of another Panose to this value.
+     * @param otherPanose Another Panose instance which is being compared to this.
+     * @param weights 10-element byte array of weights that should be used for each of the elements
+     * in the comparison.
+     * Values in this array must be between 0 and 127 inclusive.
+     * (This constant is documented at http://www.w3.org/Fonts/Panose/pan2.html#StaticDigits).
+     * Use null if all elements are to be weighted equally.
+     * @return The weighted difference between the two Panose values.
+     * A smaller value indicates that the two values are closer, and a larger
+     * value indicates that they are farther apart.
+     */
+    public long difference(final Panose otherPanose, final byte[] weights) {
+        /* This is a partial implementation of the "PANOSE Matching Heuristic" documented at:
+         * http://www.w3.org/Fonts/Panose/pan2.html#Heuristic. **/
+        byte[] weightsToUse = null;
+        if (weights == null) {
+            weightsToUse = Panose.NEUTRAL_WEIGHTS;
+        } else {
+            validateWeights(weights);
+            weightsToUse = weights;
+        }
+        long difference = 0;
+        for (int i = 0; i < Panose.Field.values().length; i++) {
+//            final int digit = panoseDescription.length - i;
+//            final int weight = (int) Math.round(Math.pow(2, digit - 1));
+            final int weight = weightsToUse[i];
+
+            final int thisDifference = this.getElement(i) - otherPanose.getElement(i);
+            difference += weight * thisDifference * thisDifference;
+        }
+        return difference;
+    }
+    
+    /*
+     *  consolas           [ 2 11 6 9 2 2 4 3 2 4 ] bold 6 ital 3
+		consolas-bold      [ 2 11 7 9 2 2 4 3 2 4 ] bold 7 ital 3
+		consolas-italic    [ 2 11 6 9 2 2 4 10 2 4 ] bold 6 ital 10
+		consolas-bolditalic[ 2 11 7 9 2 2 4 10 2 4 ] bold 7 ital 10
+		
+		cordianew           [ 2 11 3 4 2 2 2 2 2 4 ] bold 3 ital 2
+		cordianew-bolditalic[ 2 11 6 4 2 2 2 9 2 4 ] bold 6 ital 9
+		
+		calibri             [ 2 15 5 2 2 2 4 3 2 4 ] bold 5 ital 3
+		calibri-bold        [ 2 15 7 2 3 4 4 3 2 4 ] bold 7 ital 3
+		calibri-bolditalic  [ 2 15 7 2 3 4 4 10 2 4 ] bold 7 ital 10
+		
+		constantia          [ 2 3 6 2 5 3 6 3 3 3 ] bold 6 ital 3
+		constantia-bold     [ 2 3 7 2 6 3 6 3 3 3 ] bold 7 ital 3
+		                              ^ note this
+		constantia-italic   [ 2 3 6 2 5 3 6 10 3 3 ] bold 6 ital 10
+		
+		candara-bold        [ 2 14 7 2 3 3 3 2 2 4 ] bold 7 ital 2
+		candara-italic      [ 2 14 5 2 3 3 3 9 2 4 ] bold 5 ital 9
+		candara-bolditalic  [ 2 14 7 2 3 3 3 9 2 4 ] bold 7 ital 9
+		
+		cambria-bold        [ 2 4 8 3 5 4 6 3 2 4 ] bold 8 ital 3
+		cambria-italic      [ 2 4 5 3 5 4 6 10 2 4 ] bold 5 ital 10
+
+     */
+    
+    public static Panose getBold(Panose thisPanose) {
+    	
+    	byte[] panoseArray = thisPanose.getPanoseArray();
+    	
+    	if (panoseArray[2]==11) {
+    		// Already the maximum value - do nothing
+    	} else if (panoseArray[2]<8) {
+    		panoseArray[2]=9; 
+    		// 8 = bold, and even though most of the MS ClearType Collection fonts have 7 here,
+    		// experience (Times New Roman) shows it is better to be on the high side, to stop
+    		// this Panose array from being equidistant between the normal weight and the
+    		// bold weight.
+    		
+    	} else {
+    		// Do nothing, rather than increase the Weight
+    	}
+    	
+		return Panose.makeInstance(panoseArray);
+    	
+    }
+
+    public static Panose getItalic(Panose thisPanose) {
+    	
+    	byte[] panoseArray = thisPanose.getPanoseArray();
+    	
+    	if (panoseArray[7]==15) {
+    		// Already the maximum value - do nothing
+    	} else if (panoseArray[7]<9) {
+    		panoseArray[7]=10; // Most fonts have 9 or 10 here, so use 10 on the same reasoning as above.
+    	} else {
+    		// Do nothing, rather than increase the Letterform setting 
+    	}
+    	
+		return Panose.makeInstance(panoseArray);
+    	
+    }
+    
+    
+    /**
+     * Examines an array of weights, throwing various unchecked exceptions if the data is not valid.
+     * @param weights The array of weights to be tested.
+     */
+    private static void validateWeights(final byte[] weights) {
+        if (weights == null) {
+            throw new NullPointerException("Weights may not be null");
+        }
+        if (weights.length != Panose.Field.values().length) {
+            throw new IllegalArgumentException("Weights size expected: "
+                    + Panose.Field.values().length + ", actual: " + weights.length);
+        }
+        for (int i = 0; i < weights.length; i++) {
+            final byte weight = weights[i];
+            if (weight < 0
+                    || weight > Byte.MAX_VALUE) {
+                throw new IllegalArgumentException("Weight element " + i + " is outside the range "
+                        + "of 0 thru 127.");
+            }
+        }
+    }
+    
+//    /**
+//     * Tests the validity of a panose description.
+//     * @param panoseDescription The panose values to be tested.
+//     * @return True for a valid PANOSE description, or false if the input is
+//     * null, does not have 10 elements, or any of the elements do not contain
+//     * valid ASCII numerals (0 through 9).
+//     */
+//    public static boolean validPanose(final byte[] panoseDescription) {
+//        if (panoseDescription == null) {
+//        	System.out.println("null byte[]" );
+//            return false;
+//        }
+//        if (panoseDescription.length != Panose.ARRAY_SIZE) {
+//        	System.out.println("Invalid length " + panoseDescription.length );
+//            return false;
+//        }
+//        for (int i = 0; i < panoseDescription.length; i++) {
+//            final byte theByte = panoseDescription[i];
+//            String s = Byte.toString(theByte);            
+//            int n = Integer.parseInt(s);
+//            if (n < 0) {
+//            	//System.out.println("Invalid value (too small) " + theByte + " in position " + i + " of " + toString(panoseDescription) );
+//                return false;
+//            }
+//                        
+//            if (n > validMaxValues[i]) {
+//            	System.out.println("Invalid value " + n + " > " + validMaxValues[i] + " in position " + i + " of " + toString(panoseDescription) );
+//                return false;
+//            }
+//        }
+//        return true;
+//    }
+
+    
+    
+    /**
+     * Tests the validity of a panose description.
+     * @param panoseDescription The panose values to be tested.
+     * @return Null for a valid PANOSE description. For an invalid PANOSE description, returns a
+     * descriptive message indicating which element is invalid.
+     */
+    public static String validPanose(final byte[] panoseDescription) {
+        if (panoseDescription == null) {
+            return "Panose description cannot be null.";
+        }
+        if (panoseDescription.length != Panose.Field.values().length) {
+            return "Illegal Panose description size: " + panoseDescription.length;
+        }
+        for (int i = 0; i < panoseDescription.length; i++) {
+            final byte theByte = panoseDescription[i];
+            final Panose.Field panoseField = Panose.Field.values()[i];
+            final byte maxValue = panoseField.getMaxValue();
+            if (theByte < 0
+                    || theByte > maxValue) {
+                return "Invalid value " + theByte + " > " + maxValue + " in position " + i
+                        + " of " + toString(panoseDescription);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public String toString() {
+        return toString(this.panoseArray);      
+    }
+
+    /**
+     * Returns a String representation of a Panose array.
+     * @param panoseArray The Panose array to be expressed as a String.
+     * @return The String representation of <code>panoseArray</code>.
+     */
+    private static String toString(final byte[] panoseArray) {
+        final StringBuilder sb = new StringBuilder(30);
+        sb.append("[ ");
+        for (int i = 0; i < panoseArray.length; i++) {
+            final byte theByte = panoseArray[i];
+            sb.append(theByte + " ");
+        }
+        sb.append("]");
+        return sb.toString();       
+    }
+    
+}
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFile.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFile.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFile.java	(working copy)
@@ -30,7 +30,9 @@
 
 import org.apache.xmlgraphics.fonts.Glyphs;
 
+import org.apache.fop.fonts.EmbedFontInfo;
 import org.apache.fop.fonts.FontUtil;
+import org.apache.fop.fonts.Panose;
 
 /**
  * Reads a TrueType file or a TrueType Collection.
@@ -48,9 +50,12 @@
     public static final boolean TRACE_ENABLED = false;
 
     private String encoding = "WinAnsiEncoding";    // Default encoding
+    
+    /** Array containing the Panose information. */
+    private Panose panose;
 
     private short firstChar = 0;
-    private boolean isEmbeddable = true;
+    private boolean isEmbeddable = false; // until proven otherwise!
     private boolean hasSerifs = true;
     /**
      * Table directory
@@ -549,8 +554,10 @@
      */
     public String getPostScriptName() {
         if (postScriptName.length() == 0) {
+        	System.out.println("TTFFile - Hmmm, Composed postscript name from fullname.");
             return FontUtil.stripWhiteSpace(getFullName());
         } else {
+//        	System.out.println("TTFFile - Cool, there was a proper postScript name, namely: " + postScriptName);
             return postScriptName;
         }
     }
@@ -743,6 +750,7 @@
      * @return boolean True if it may be embedded
      */
     public boolean isEmbeddable() {
+    	
         return isEmbeddable;
     }
 
@@ -988,7 +996,10 @@
         if (dirTabs.get("OS/2") != null) {
             seekTab(in, "OS/2", 2 * 2);
             this.usWeightClass = in.readTTFUShort();
+            
+            // usWidthClass
             in.skip(2);
+            
             int fsType = in.readTTFUShort();
             if (fsType == 2) {
                 isEmbeddable = false;
@@ -996,10 +1007,21 @@
                 isEmbeddable = true;
             }
             in.skip(11 * 2);
-            in.skip(10); //panose array
+            
+            //in.skip(10); //panose array
+            final byte[] panoseArray = new byte[10];
+            for (int i = 0; i < panoseArray.length; i++) {
+                panoseArray[i] = in.read();
+            }
+            this.panose = Panose.makeInstance(panoseArray);
+            
+            
+            /* Skip ulUnicodeRange1 - 4. */            
             in.skip(4 * 4); //unicode ranges
             in.skip(4);
             in.skip(3 * 2);
+           
+            /* Read sTypoAscender. */            
             int v;
             os2Ascender = in.readTTFShort(); //sTypoAscender
             log.debug("sTypoAscender: " + os2Ascender 
@@ -1474,6 +1496,66 @@
         }
     }
 
+    /**
+     * Return TTC font names
+     * @param in FontFileReader to read from
+     * @return True if not collection or font name present, false otherwise
+     * @throws IOException In case of an I/O problem
+     */
+    public final List<String> getTTCnames(FontFileReader in) throws IOException {
+    	
+    	List<String> fontNames = new java.util.ArrayList<String>();
+    	
+        String tag = in.readTTFString(4);
+
+        if ("ttcf".equals(tag)) {
+            // This is a TrueType Collection
+            in.skip(4);
+
+            // Read directory offsets
+            int numDirectories = (int)in.readTTFULong();
+            // int numDirectories=in.readTTFUShort();
+            long[] dirOffsets = new long[numDirectories];
+            for (int i = 0; i < numDirectories; i++) {
+                dirOffsets[i] = in.readTTFULong();
+            }
+
+            log.info("This is a TrueType collection file with "
+                                   + numDirectories + " fonts");
+            log.info("Containing the following fonts: ");
+            // Read all the directories and name tables to check
+            // If the font exists - this is a bit ugly, but...
+            boolean found = false;
+
+            // Iterate through all name tables even if font
+            // Is found, just to show all the names
+            long dirTabOffset = 0;
+            for (int i = 0; (i < numDirectories); i++) {
+                in.seekSet(dirOffsets[i]);
+                readDirTabs(in);
+
+                readName(in);
+
+                log.info(fullName);
+                fontNames.add(fullName);
+
+                // Reset names
+                notice = "";
+                fullName = "";
+                familyNames.clear();
+                postScriptName = "";
+                subFamilyName = "";
+            }
+
+            in.seekSet(0);
+            return fontNames;
+        } else {
+        	log.error("Not a TTC!");
+        	return null;
+        }
+    }
+    
+    
     /*
      * Helper classes, they are not very efficient, but that really
      * doesn't matter...
@@ -1568,4 +1650,8 @@
             ioe.printStackTrace(System.err);
         }
     }
+
+	public Panose getPanose() {
+		return panose;
+	}
 }
\ No newline at end of file
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFontLoader.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFontLoader.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/fonts/truetype/TTFFontLoader.java	(working copy)
@@ -51,6 +51,10 @@
     
     /** {@inheritDoc} */
     protected void read() throws IOException {
+        read(null);
+    }
+
+    public void read(String ttcFontName) throws IOException {
         InputStream in = openFontUri(resolver, this.fontFileURI);
         try {
             TTFFile ttf = new TTFFile();
@@ -55,7 +59,7 @@
         try {
             TTFFile ttf = new TTFFile();
             FontFileReader reader = new FontFileReader(in);
-            boolean supported = ttf.readFont(reader, null);
+            boolean supported = ttf.readFont(reader, ttcFontName);
             if (!supported) {
                 throw new IOException("TrueType font is not supported: " + fontFileURI);
             }
@@ -65,7 +69,8 @@
             IOUtils.closeQuietly(in);
         }
     }
-
+    
+    
     private void buildFont(TTFFile ttf) {
         if (ttf.isCFF()) {
             throw new UnsupportedOperationException(
@@ -92,6 +97,9 @@
         returnFont.setMissingWidth(0);
         returnFont.setWeight(ttf.getWeightClass());
         
+        returnFont.setPanose(ttf.getPanose() );
+        returnFont.setEmbeddable(ttf.isEmbeddable() );
+        
         multiFont.setCIDType(CIDFontType.CIDTYPE2);
         int[] wx = ttf.getWidths();
         multiFont.setWidthArray(wx);
Index: /home/jharrop/workspace200711/fop/src/java/org/apache/fop/render/PrintRendererConfigurator.java
===================================================================
--- /home/jharrop/workspace200711/fop/src/java/org/apache/fop/render/PrintRendererConfigurator.java	(revision 631408)
+++ /home/jharrop/workspace200711/fop/src/java/org/apache/fop/render/PrintRendererConfigurator.java	(working copy)
@@ -230,10 +230,19 @@
             URL fontUrl = (URL)iter.next();
             // parse font to ascertain font info
             FontInfoFinder finder = new FontInfoFinder();
-            EmbedFontInfo fontInfo = finder.find(fontUrl, resolver, fontCache);
-            if (fontInfo != null) {
-                fontInfoList.add(fontInfo);                
-            }
+            //EmbedFontInfo fontInfo = finder.find(fontUrl, resolver, fontCache);
+    		List<EmbedFontInfo> embedFontInfoList = finder.find(fontUrl, resolver, fontCache);		
+    		
+    		if (embedFontInfoList==null) {
+    			return;
+    		}
+    		
+    		for ( EmbedFontInfo fontInfo : embedFontInfoList ) {
+            
+	            if (fontInfo != null) {
+	                fontInfoList.add(fontInfo);                
+	            }
+    		}
         }
     }
 
@@ -307,7 +316,10 @@
             }
             if (fontFile != null) {
                 FontInfoFinder finder = new FontInfoFinder();
-                return finder.find(fontUrl, fontResolver, fontCache);
+                return finder.find(fontUrl, fontResolver, fontCache).get(0);
+                	// TODO - fixme.  This is a quick hack.  If it is a TTC,
+                	// it will only return the EmbedFontInfo corresponding 
+                	// to the first font.
             } else {
                 return null;
             }
